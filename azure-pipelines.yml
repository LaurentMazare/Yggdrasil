# Trigger on pushes to `master`
trigger:
- master
- mg/test-commit-message

# Trigger on PRs against `master`
pr:
- master

# By default, use the `Native` pool of agents
pool: Native

variables:
    JULIA: unbuffer julia --project=$(Build.SourcesDirectory)/.ci --color=yes

jobs:
- job: generator
  steps:
  - checkout: self
    fetchDepth: 99999
    clean: true
  - bash: |
      # Be fragile, like a beautiful porcelain doll
      set -e

      echo "BUILD_SOURCEVERSIONMESSAGE: ${BUILD_SOURCEVERSIONMESSAGE}"
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    name: mtrx

- job: jll_init
  dependsOn: generator
  timeoutInMinutes: 10
  cancelTimeoutInMinutes: 2
  strategy:
    matrix: $[ dependencies.generator.outputs['mtrx.projects'] ]
  variables:
    projects: $[ dependencies.generator.outputs['mtrx.projects'] ]
  steps:
  - script: |
      # Fail on error
      set -e

      cd $(PROJECT)
      echo "Generating meta.json..."
      $(JULIA) --compile=min ./build_tarballs.jl --meta-json=$(Agent.TempDirectory)/$(NAME).meta.json
      echo "Initializing JLL package..."
      $(JULIA) $(Build.SourcesDirectory)/.ci/jll_init.jl "$(Agent.TempDirectory)/${NAME}.meta.json"
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    displayName: "initialize JLL package"
    condition: and(and(ne(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.SourceBranch'], 'refs/heads/master')), ne(variables['projects'], ''))

- job: build
  dependsOn:
   - generator
   - jll_init
  timeoutInMinutes: 240
  cancelTimeoutInMinutes: 2
  strategy:
    matrix: $[ dependencies.generator.outputs['mtrx.projplatforms'] ]
  variables:
    projplatforms: $[ dependencies.generator.outputs['mtrx.projplatforms'] ]
  steps:
  - script: |
      # Fail on error
      set -e

      # Cleanup temporary things that might have been left-over
      ./clean_builds.sh
      ./clean_products.sh

      cd $(PROJECT)
      $(JULIA) ./build_tarballs.jl --verbose $(PLATFORM)

      # After building, we take the single tarball produced with the proper NAME, and upload it:
      TARBALLS=( ./products/${NAME%@*}*${PLATFORM}*.tar.gz )
      if [[ "${#TARBALLS[@]}" != 1 ]]; then
          echo "Multiple tarballs?  This isn't right!" >&2
          exit 1
      fi

      # Upload with curl
      ACL="x-amz-acl:public-read"
      CONTENT_TYPE="application/x-gtar"
      BUCKET="julia-bb-buildcache"
      BUCKET_PATH="${BB_HASH}/${PROJ_HASH}/${PLATFORM}.tar.gz"
      DATE="$(date -R)"
      S3SIGNATURE=$(echo -en "PUT\n\n${CONTENT_TYPE}\n${DATE}\n${ACL}\n/${BUCKET}/${BUCKET_PATH}" | openssl sha1 -hmac "${S3SECRET}" -binary | base64)
      HOST="${BUCKET}.s3.amazonaws.com"
      echo "Uploading artifact to https://${HOST}/${BUCKET_PATH}"
      curl -X PUT -T "${TARBALLS[0]}" \
          -H "Host: ${HOST}" \
          -H "Date: ${DATE}" \
          -H "Content-Type: ${CONTENT_TYPE}" \
          -H "${ACL}" \
          -H "Authorization: AWS ${S3KEY}:${S3SIGNATURE}" \
          "https://${HOST}/${BUCKET_PATH}"

      if [[ "$?" != 0 ]]; then
          echo "Failed to upload artifact!" >&2
          exit 1
      fi
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
      S3KEY: $(S3KEY)
      S3SECRET: $(S3SECRET)
    displayName: "run build_tarballs.jl"
    condition: and(ne(variables['projplatforms'], ''), ne(variables['projplatforms'], '{ }'))

- job: register
  dependsOn:
  - generator
  - build
  strategy:
    matrix: $[ dependencies.generator.outputs['mtrx.projects'] ]
    maxParallel: 1
  variables:
    projects: $[ dependencies.generator.outputs['mtrx.projects'] ]
  steps:
  - script: |
      # Fail on error
      set -e

      cd $(PROJECT)
      echo "Generating meta.json..."
      $(JULIA) --compile=min ./build_tarballs.jl --meta-json=$(Agent.TempDirectory)/$(NAME).meta.json
      echo "Registering $(NAME)..."
      export BB_HASH PROJ_HASH
      $(JULIA) $(Build.SourcesDirectory)/.ci/register_package.jl $(Agent.TempDirectory)/$(NAME).meta.json --verbose
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    displayName: "register JLL package"
    # We only register if this is on `master`; same as setting `${DEPLOY}` above.
    condition: and(and(ne(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.SourceBranch'], 'refs/heads/master')), ne(variables['projects'], ''))

